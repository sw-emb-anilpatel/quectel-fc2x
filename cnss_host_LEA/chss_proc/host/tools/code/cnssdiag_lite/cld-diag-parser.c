/*
 * Copyright (c) 2015-17 Qualcomm Atheros, Inc.
 *
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 */

/*
 * Copyright (c) 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Chris Torek.
 *
 * Copyright (c) 2011 The FreeBSD Foundation
 * All rights reserved.
 * Portions of this software were developed by David Chisnall
 * under sponsorship from the FreeBSD Foundation.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2014-2015 The Linux Foundation. All rights reserved.
 *
 * Previously licensed under the ISC license by Qualcomm Atheros, Inc.
 *
 *
 * Permission to use, copy, modify, and/or distribute this software for
 * any purpose with or without fee is hereby granted, provided that the
 * above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE
 * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
 * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR
 * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * This file was originally distributed by Qualcomm Atheros, Inc.
 * under proprietary terms before Copyright ownership was assigned
 * to the Linux Foundation.
 */

#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include "cld-diag-parser.h"
#include <sys/time.h>

#ifdef CONFIG_CLD80211_LIB
extern struct cld80211_ctx *cldctx;
#endif

typedef struct diag_entry {
	uint32_t id;
	boolean isUsed;

	/* database - userspace */
	char *format;
	char *pack;

	/* runtime message - generated by target */
	char *msg;
	uint32_t msg_len;
}diag_entry;

typedef struct file_header {
	int32_t  file_version;
	int32_t  n_entries;
	int32_t  n_usedEntries;
	int32_t  hash;
}file_header;

static diag_entry *gdiag_db[NUM_OF_DRIVERS] = {0};
static file_header *gdiag_header[NUM_OF_DRIVERS] = {0};
static int32_t gisdiag_init[NUM_OF_DRIVERS] = {0};

static int /*gdiag_sock_fd = 0,*/ goptionflag = 0;
extern int avail_space;
extern int log_path_flag;
extern int free_mem_threshold;
static uint64_t base_timestamp = 0;
extern unsigned int configured_buffer_size;
extern int max_no_buffer;
extern uint8_t gwlan_dev;
extern struct cnss_log_file_data log_file[LOG_FILE_MAX];
extern char napier_db_parse_path[MAX_SIZE];
extern char legacy_db_parse_path[MAX_SIZE];
/*
 * Flags used during conversion.
 */
#define ALT         0x001		/* alternate form */
#define LADJUST     0x004		/* left adjustment */
#define LONGDBL     0x008		/* long double */
#define LONGINT     0x010		/* long integer */
#define LLONGINT    0x020		/* long long integer */
#define SHORTINT    0x040		/* short integer */
#define ZEROPAD     0x080		/* zero (as opposed to blank) pad */
#define FPT         0x100		/* Floating point number */
#define GROUPING    0x200		/* use grouping ("'" flag) */
                                /* C99 additional size modifiers: */
#define SIZET       0x400		/* size_t */
#define PTRDIFFT    0x800		/* ptrdiff_t */
#define INTMAXT     0x1000		/* intmax_t */
#define CHARINT     0x2000		/* print char using int format */

#if DIAG_KEEP_ORIG
/*
 * macros to safely extract 8, 16, 32, or 64-bit values from byte buffer
 */
#define GET_8(v, msg, msg_len) do {         \
	if (msg_len < sizeof(uint8_t)) {    \
		goto msg_error;             \
	}                                   \
	v = *msg;                           \
	msg += sizeof(uint8_t);             \
	msg_len -= sizeof(uint8_t);         \
} while (0)

#define _GET_LE16(a) ( \
	(((uint16_t)(a)[1]) << 8) | \
	 ((uint16_t)(a)[0]))
#define GET_LE16(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint16_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE16(msg);                 \
	msg += sizeof(uint16_t);            \
	msg_len -= sizeof(uint16_t);        \
} while (0)
#endif

#define _GET_LE32(a) ( \
	(((uint32_t)(a)[3]) << 24) | \
	(((uint32_t)(a)[2]) << 16) | \
	(((uint32_t)(a)[1]) << 8)  | \
	((uint32_t)(a)[0]))

#define GET_LE32(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint32_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE32(msg);                 \
	msg += sizeof(uint32_t);            \
	msg_len -= sizeof(uint32_t);        \
} while (0)

#if DIAG_KEEP_ORIG
#define _GET_LE64(a) ( \
	(((uint64_t)(a)[7]) << 56) | \
	(((uint64_t)(a)[6]) << 48) | \
	(((uint64_t)(a)[5]) << 40) | \
	(((uint64_t)(a)[4]) << 32) | \
	(((uint64_t)(a)[3]) << 24) | \
	(((uint64_t)(a)[2]) << 16) | \
	(((uint64_t)(a)[1]) << 8) | \
	((uint64_t)(a)[0]))
#define GET_LE64(v, msg, msg_len) do {      \
	if (msg_len < sizeof(uint64_t)) {   \
		goto msg_error;             \
	}                                   \
	v = _GET_LE64(msg);                 \
	msg += sizeof(uint64_t);            \
	msg_len -= sizeof(uint64_t);        \
} while (0)

/*
 * pack_printf derived from Rome FW's cmnos_vprintf which
 * internally is using the FreeBSD version implementation.
 */
#endif

/*
 * Macros for converting digits to letters and vice versa
 */
#define to_digit(c)	((c) - '0')
#define is_digit(c)	((unsigned)to_digit(c) <= 9)

#define to_char(n)	((n) + '0')

/*
 * Convert an unsigned long to ASCII for printf purposes, returning
 * a pointer to the first character of the string representation.
 * Octal numbers can be forced to have a leading zero; hex numbers
 * use the given digits.
 */
static char *
__ultoa(unsigned long long val, char *endp, int base, int octzero,
        const char *xdigs)
{
	char *cp = endp;

	if (endp == NULL || xdigs == NULL) {
		debug_printf("%s: Input parameter invalid", __func__);
		return endp;
	}

	/*
	 * Handle the three cases separately, in the hope of getting
	 * better/faster code.
	 */
	switch (base) {
	case 10:
		if (val < 10) {	/* many numbers are 1 digit */
			*--cp = to_char(val);
			return (cp);
		}
		do {
			*--cp = to_char(val % 10);
			val /= 10;
		} while (val != 0);
		break;

	case 8:
		do {
			*--cp = to_char(val & 7);
			val >>= 3;
		} while (val);
		if (octzero && *cp != '0')
			*--cp = '0';
		break;

	case 16:
		do {
			*--cp = xdigs[val & 15];
			val >>= 4;
		} while (val);
		break;

	case 2:
		do {
			*--cp = to_char(val & 1);
			val >>= 1;
		} while (val);
		break;
	default:			/* oops */
		break;
	}
	return (cp);
}

/* Return successive characters in a format string. */
char fmt_next_char(const char **fmtptr)
{
	char ch;

	ch = **fmtptr;
	if (ch != '\0') {
		(*fmtptr)++;
	}
	return ch;
}

/* Return current characters in a format string. */
char fmt_cur_char(const char **fmtptr)
{
	char ch;
	ch = **fmtptr;
	return ch;
}

long long get_value_from_msg(char pack, uint8_t **msg, uint32_t *msg_len)
{
	int32_t val = 0;

	UNUSED(pack);

	GET_LE32(val, *msg, *msg_len);

	return val;

msg_error:
	printf("Fatal error to fetch param\n");
	return 0;
}

/*
 * The size of the buffer we use as scratch space for integer
 * conversions, among other things.  We need enough space to
 * write a uintmax_t in octal (plus one byte).
 */
#define	BUF	(sizeof(long long)*8)

static int
pack_printf(
    void (*write_char)(char **pbs, char *be, char c),
    char **pbuf_start,
    char *buf_end,
    const char *fmt0,
    const char *pack,
    uint8_t *msg,
    uint32_t msg_len)
{
	const char *fmt;     /* format string */
	int ch;              /* character from fmt */
	int n;               /* handy integer (short term usage) */
	char *cp;            /* handy char pointer (short term usage) */
	int flags;           /* flags as above */
	int ret;             /* return value accumulator */
	int width;           /* width from format (%8d), or 0 */
	int prec;            /* precision from format; <0 for N/A */
	char sign;           /* sign prefix (' ', '+', '-', or \0) */

	long long ulval;     /* integer arguments %[diouxX] */
	int base;            /* base for [diouxX] conversion */
	int dprec;           /* a copy of prec if [diouxX], 0 otherwise */
	int realsz;          /* field size expanded by dprec, sign, etc */
	int size;            /* size of converted field or string */
	int prsize;          /* max size of printed field */
	const char *xdigs;   /* digits for %[xX] conversion */
	char buf[BUF];       /* buffer with space for digits of uintmax_t */
	char ox[2];          /* space for 0x; ox[1] is either x, X, or \0 */
	int pad;             /* pad */

	static const char xdigs_lower[16] = "0123456789abcdef";
	static const char xdigs_upper[16] = "0123456789ABCDEF";

	fmt = (char *)fmt0;
	ret = 0;
	size = 0;
	xdigs = xdigs_lower;

	/*
	 * Scan the format for conversions (`%' character).
	 */
	for (;;) {
		for (cp = (char *)fmt; (ch = fmt_cur_char(&fmt)) != '\0' && ch != '%';
			 ch = fmt_next_char(&fmt)){
			write_char(pbuf_start, buf_end, ch);
			ret++;
		}

		if (ch == '\0')
			goto done;
		fmt_next_char(&fmt);		/* skip over '%' */

		flags = 0;
		dprec = 0;
		width = 0;
		prec = -1;
		sign = '\0';
		ox[1] = '\0';

rflag:		ch = fmt_next_char(&fmt);
reswitch:	switch (ch) {
		case ' ':
			/*-
			 * ``If the space and + flags both appear, the space
			 * flag will be ignored.''
			 *	-- ANSI X3J11
			 */
			if (!sign)
				sign = ' ';
			goto rflag;
		case '-':
			flags |= LADJUST;
			goto rflag;
		case '+':
			sign = '+';
			goto rflag;
		case '.':
			ch = fmt_next_char(&fmt);
			prec = 0;
			while (is_digit(ch)) {
				prec = 10 * prec + to_digit(ch);
				ch = fmt_next_char(&fmt);
			}
			goto reswitch;
		case '0':
			/*-
			 * ``Note that 0 is taken as a flag, not as the
			 * beginning of a field width.''
			 *	-- ANSI X3J11
			 */
			flags |= ZEROPAD;
			goto rflag;
		case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			n = 0;
			do {
				n = 10 * n + to_digit(ch);
				ch = fmt_next_char(&fmt);
			} while (is_digit(ch));
			width = n;
			goto reswitch;
		case 'l':
			if (flags & LONGINT) {
				flags &= ~LONGINT;
				flags |= LLONGINT;
			} else
				flags |= LONGINT;
			goto rflag;
		case 'C':
			flags |= LONGINT; /* Do not support WCHAR */
			/*FALLTHROUGH*/
		case 'c':
			if (msg_len) {
				cp = (char *)msg++;
				msg_len--;
				size = 1;
				sign = '\0';
			}
			break;
		case 'D':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'd':
		case 'i':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg, &msg_len);
			if (ulval < 0) {
				ulval = -ulval;
				sign = '-';
			}
			base = 10;
			goto number;
		case 'p':
			/*-
			 * ``The argument shall be a pointer to void.  The
			 * value of the pointer is converted to a sequence
			 * of printable characters, in an implementation-
			 * defined manner.''
			 *	-- ANSI X3J11
			 */
			ulval = (int)get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			xdigs = xdigs_lower;
			ox[1] = 'x';
			goto nosign;
		case 'S':
		case 's':
			/* Not Supported */
			cp = "<null>";
			size = 0;
			while (cp[size] != '\0') size++;
			sign = '\0';
			break;
		case 'O':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'o':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 8;
			goto nosign;
		case 'B':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'b':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 2;
			goto nosign;
		case 'U':
			flags |= LONGINT;
			/*FALLTHROUGH*/
		case 'u':
			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 10;
			goto nosign;
		case 'X':
			xdigs = xdigs_upper;
			goto hex;
		case 'x':
			xdigs = xdigs_lower;
hex:

			ulval = get_value_from_msg(fmt_next_char(&pack), &msg,
							&msg_len);
			base = 16;
			/* leading 0x/X only if non-zero */
			if (flags & ALT && ulval != 0)
				ox[1] = ch;

			/* unsigned conversions */
nosign:			sign = '\0';
			/*-
			 * ``... diouXx conversions ... if a precision is
			 * specified, the 0 flag will be ignored.''
			 *	-- ANSI X3J11
			 */
number:			if ((dprec = prec) >= 0)
					flags &= ~ZEROPAD;

			/*-
			 * ``The result of converting a zero value with an
			 * explicit precision of zero is no characters.''
			 *	-- ANSI X3J11
			 *
			 * ``The C Standard is clear enough as is.  The call
			 * printf("%#.0o", 0) should print 0.''
			 *	-- Defect Report #151
			 */
			cp = buf + BUF;
			if (ulval != 0 || prec != 0 ||
			    (flags & ALT && base == 8)){
				cp = __ultoa(ulval, cp, base,
				    flags & ALT, xdigs);
			}
			size = buf + BUF - cp;

			break;
		default:	/* "%?" prints ?, unless ? is NUL */
			if (ch == '\0')
				goto done;
			/* pretend it was %c with argument ch */
			cp = buf;
			*cp = ch;
			size = 1;
			sign = '\0';
			break;
		}

		/*
		 * All reasonable formats wind up here.  At this point, `cp'
		 * points to a string which (if not flags&LADJUST) should be
		 * padded out to `width' places.  If flags&ZEROPAD, it should
		 * first be prefixed by any sign or other prefix; otherwise,
		 * it should be blank padded before the prefix is emitted.
		 * After any left-hand padding and prefixing, emit zeroes
		 * required by a decimal [diouxX] precision, then print the
		 * string proper, then emit zeroes required by any leftover
		 * floating precision; finally, if LADJUST, pad with blanks.
		 *
		 * Compute actual size, so we know how much to pad.
		 * size excludes decimal prec; realsz includes it.
		 */
		realsz = dprec > size ? dprec : size;
		if (sign)
			realsz++;
		if (ox[1])
			realsz += 2;

		prsize = width > realsz ? width : realsz;
		pad =  width - realsz;

		/* right-adjusting blank padding */
		if ((flags & (LADJUST|ZEROPAD)) == 0){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* prefix */
		if (sign){
			write_char(pbuf_start, buf_end, sign);
			pad--;
		}

		if (ox[1]) {	/* ox[1] is either x, X, or \0 */
			ox[0] = '0';
			write_char(pbuf_start, buf_end, ox[0]);
			pad--;
			write_char(pbuf_start, buf_end, ox[1]);
			pad--;
		}

		/* right-adjusting zero padding */
		if ((flags & (LADJUST|ZEROPAD)) == ZEROPAD){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, '0');
			}
		}

		while (size-- > 0) {
			ch = *cp++;
			(*write_char)(pbuf_start, buf_end, ch);
		}

		/* left-adjusting padding (always blank) */
		if (flags & LADJUST){
			while(pad-- > 0){
				write_char(pbuf_start, buf_end, ' ');
			}
		}

		/* finally, adjust ret */
		ret += prsize;
	}
done:

	return (ret);
	/* NOTREACHED */
}

static void
format_pack( const char *pack,  char *buf, uint32_t buflen)
{
	char c;
	uint32_t num = 0, index = 0, i = 0;
	boolean isfound = 0;
	memset(buf, 0 , buflen);
	while ((c = fmt_next_char(&pack)) != '\0') {
		if (index >= buflen -1)
			break;
		while (is_digit(c)) {
			num = (i++ * 10) + (c - '0');
			c = fmt_next_char(&pack);
			isfound = TRUE;
		}
		if (isfound) {
			while (num--) {
				buf[index++] = c;
				if (index >= buflen -1)
					break;
			}
			num = 0;
			i = 0;
		}
		else
			buf[index++] = c;
	}
	buf[index] = '\0';
}

void appendLocalTime(char* tmbuf) {
	time_t now;
	struct tm *qtm;
	struct timeval tv;
	char buf[TIME_DATA_SIZE];

	gettimeofday(&tv, NULL);
	now = tv.tv_sec;
	qtm = localtime(&now);
	if ((qtm) && (tmbuf != NULL)) {
		strftime(buf, sizeof(buf), "%H:%M:%S", qtm);
		snprintf(tmbuf, 20, "%s.%06d ", buf, (int)tv.tv_usec);
	}
}


void cnss_write_buf_logs(int log_len, char *log, enum fileType type)
{
	struct cnss_log_file_data *lfd;

	if (type >= LOG_FILE_MAX)
		return;
	lfd = &log_file[type];
	if (!lfd->fp)
		return;
	if ((avail_space  < free_mem_threshold) &&
			(log_path_flag == WRITE_TO_INTERNAL_SDCARD)) {
		android_printf("Device free memory is insufficient");
		return;
	}
	if (lfd->free_buf_mem <= log_len) {
		fwrite(lfd->buf, sizeof(char), (lfd->buf_ptr - lfd->buf), lfd->fp);
		if (ftell(lfd->fp) >= max_file_size) {
			fflush(lfd->fp);
			fclose(lfd->fp);
			backup_file(type);
			if (type == HOST_LOG_FILE ||
						type == FW_LOG_FILE
						|| type == HOST_QXDM_LOG_FILE
						|| type == FW_QXDM_LOG_FILE) {
				cnss_open_log_file(TRUE, type);
				lfd->wrap_cnt++;
#if DIAG_KEEP_ORIG
				fprintf(lfd->fp, "[INFO]:File Wrapped for %d times\n",
						lfd->wrap_cnt);
				fclose(lfd->fp);
#endif
			}
		}
		lfd->free_buf_mem = configured_buffer_size;
		lfd->buf_ptr = lfd->buf;
		memset(lfd->buf_ptr, 0, lfd->free_buf_mem);

		if (type == HOST_QXDM_LOG_FILE
		    || type == FW_QXDM_LOG_FILE) {
		struct qmdl_file_hdr file_hdr;
		file_hdr.hdr_len = sizeof(struct qmdl_file_hdr);
		file_hdr.version = 1;
		file_hdr.data_type = 0;
		file_hdr.guid_list_count = 0;
		cnss_write_buf_logs(sizeof(struct qmdl_file_hdr), (char *)&file_hdr, type);
	}
	}
	memcpy(lfd->buf_ptr, log, log_len);
	lfd->buf_ptr += log_len;
	lfd->free_buf_mem -= log_len;

}

/* Allocate buffer to save text logs to QXDM / APEX container log packet format
 * to local file or diag module.
 */
void *cnss_diag_buf_alloc(uint8_t log_source)
{
#ifdef ANDROID
	time_genoff_info_type   genoff;
#else
	struct timespec t;
#endif
	struct cnss_log_pkt_buf *log_pkt_buf;
	struct cnss_diag_log_buf *diag_buf;
	struct cnss_diag_file_buf *diag_file_buf;

	if (optionflag & LOGFILE_QXDM_FLAG) {
		// Local buffer for file
		diag_file_buf = malloc(CNSS_DIAG_LOG_BUF_MAX +
					sizeof (struct cnss_diag_file_buf));
		if (!diag_file_buf)
			return NULL;
		memset(diag_file_buf, 0, CNSS_DIAG_LOG_BUF_MAX +
					sizeof (struct cnss_diag_file_buf));
		diag_file_buf->start_marker = 0x7E;
		diag_file_buf->version = 1;
		diag_file_buf->chunk_length = 0;
		diag_file_buf->std_hdr.cmd_code = 0x10;
		diag_file_buf->std_hdr.more = 0;
		diag_file_buf->std_hdr.len1 = sizeof(struct
				cnss_diag_std_file_buf_hdr_log_pkt_hdr);
		diag_file_buf->std_hdr.len2 = sizeof(struct
				cnss_diag_std_file_buf_hdr_log_pkt_hdr);
		diag_file_buf->std_hdr.log_pkt_hdr.log_code = CNSS_DIAG_LOG_ID;
		diag_file_buf->std_hdr.log_pkt_hdr.ts = 0;
		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
	}else {
		// Diag module buffer alloc API
		diag_buf = log_alloc(CNSS_DIAG_LOG_ID, CNSS_DIAG_LOG_BUF_MAX);
		if(!diag_buf)
			return NULL;
		memset(diag_buf, 0, CNSS_DIAG_LOG_BUF_MAX);
		log_pkt_buf = &diag_buf->log_pkt_buf;
	}

	log_pkt_buf->hdr.version = 1;
	log_pkt_buf->hdr.source = log_source;
	log_pkt_buf->hdr.type = LOG_TYPE_F3_STRING;
	log_pkt_buf->hdr.num_ent = 0;

#ifdef ANDROID
	genoff.base = ATS_MODEM;
	genoff.unit = TIME_MSEC;
	genoff.operation = T_GET;
	genoff.ts_val = &log_pkt_buf->hdr.time_stamp;
	if (time_genoff_operation(&genoff))
		log_pkt_buf->hdr.time_stamp = 0;
#else
	clock_gettime(CLOCK_MONOTONIC, &t);
	// sec->msec + nsec->msec conversion
	log_pkt_buf->hdr.time_stamp = ((unsigned long long)t.tv_sec * 1000) +
				((unsigned long long)t.tv_nsec / 1000000);
#endif
	// Diag Standard: Convert to 1.25 ms and shift << 16
	log_pkt_buf->hdr.time_stamp =
			((log_pkt_buf->hdr.time_stamp / 4ll) * 5ll) << 16;
	if (optionflag & LOGFILE_QXDM_FLAG)
		return diag_file_buf;
	else
		return diag_buf;
}

/* Commit container log packet to file buffer or directly to DIAG Module */
void cnss_diag_log_commit(void *buf, int flag, uint8_t log_source)
{
	struct cnss_log_pkt_buf *log_pkt_buf;
	struct cnss_diag_file_buf *diag_file_buf = NULL;
	int tot_file_buf_chunk_len;

	if (flag ==  LOGFILE_QXDM_FLAG) {
		diag_file_buf = buf;
		/*
                debug_printf("DIAG FILE Buf Data:\n%x Ver: %d Len: %d CC: %d More: %d len1: %d len2: %d LC: %d TS: %"PRIu64"\n",
                        diag_file_buf->start_marker,
                        diag_file_buf->version,
                        diag_file_buf->chunk_length,
                        diag_file_buf->std_hdr.cmd_code,
                        diag_file_buf->std_hdr.more,
                        diag_file_buf->std_hdr.len1,
                        diag_file_buf->std_hdr.len2,
                        diag_file_buf->std_hdr.log_pkt_hdr.log_code,
                        diag_file_buf->std_hdr.log_pkt_hdr.ts);*/

		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
		/*
                debug_printf("Log chunk Buf Data:\nVer: %d SRC: %d Type: %d Num_ent: %d TS: %"PRIu64"\n",
                        log_pkt_buf->hdr.version,
                        log_pkt_buf->hdr.source,
                        log_pkt_buf->hdr.type,
                        log_pkt_buf->hdr.num_ent,
                        log_pkt_buf->hdr.time_stamp);*/

		// Set end marker
		*((uint8_t *)(((uint8_t *) log_pkt_buf) + diag_file_buf->chunk_length)) = 0x7E;
		tot_file_buf_chunk_len = diag_file_buf->chunk_length +
					sizeof(struct cnss_diag_file_buf);
		diag_file_buf->std_hdr.len1 += diag_file_buf->chunk_length;
		diag_file_buf->std_hdr.len2 += diag_file_buf->chunk_length;
		diag_file_buf->chunk_length +=
				sizeof(struct cnss_diag_std_file_buf_hdr);
		// Save to file
		if (log_source == LOG_SOURCE_HOST)
			cnss_write_buf_logs(tot_file_buf_chunk_len,
				(char *)diag_file_buf, HOST_QXDM_LOG_FILE);
		else
			cnss_write_buf_logs(tot_file_buf_chunk_len,
				(char *)diag_file_buf, FW_QXDM_LOG_FILE);
	} else {
		// Commit to Diag module
		log_commit(buf);
	}
}

void cnss_diag_log_entry_cur_time(uint8_t log_source, uint64_t *cur_time)
{
	// Following qcacld-3.0 Helium and Napier use Qtimer Stamp for HOST and FW
	if (gwlan_dev == CNSS_DIAG_WLAN_DEV_UNDEF) {
		*cur_time = 0;
	} else if (gwlan_dev == CNSS_DIAG_WLAN_HEL_DEV &&
				 gwlan_dev == CNSS_DIAG_WLAN_NAP_DEV) {
			/* temp set 0 for compiling error */
			*cur_time = 0;
/*
#if __aarch64__
		asm volatile("mrs %0, cntpct_el0" : "=r" (cur_time));
#else
		asm volatile("mrrc p15, 0, %Q0, %R0, c14" : "=r" (cur_time));
#endif
		*cur_time /= QTIMER_FREQ_KHZ;
*/
	} else {
		// Following qcacld-3.0 Rome / Tuf uses Kernel boot time Stamp
		// for FW sync and timeofday for HOST logs to correlate with User space.
		if (log_source == LOG_SOURCE_HOST) {
			struct timeval tv;
			struct tm *day_time;
			gettimeofday(&tv, NULL);
			day_time = localtime((time_t *)&tv.tv_sec);
			*cur_time = ((day_time->tm_hour * 3600 + day_time->tm_min * 60 +
				day_time->tm_sec) * 1000) + (tv.tv_usec / 1000);
		} else {
			struct timespec t;
			clock_gettime(CLOCK_MONOTONIC, &t);
			// sec->msec + nsec->msec conversion
			*cur_time = ((unsigned long long)t.tv_sec * 1000) +
				((unsigned long long)t.tv_nsec / 1000000);
		}
	}
}

void cnss_diag_log_entry_create(struct cnss_log_ent *log, char *log_txt_buf,
				uint8_t log_source, uint64_t cur_time)
{
	int log_txt_len, hh, mm, ss, ts_us;
	uint64_t log_time = 0;
	char *ts_ptr;

	log_txt_len = strlen(log_txt_buf) + 1;
	log->txt_len = log_txt_len;
	if (gwlan_dev == CNSS_DIAG_WLAN_DEV_UNDEF) {
		log->delta_time = 0;
	} else {
		ts_ptr = log_txt_buf;
		if (log_source == LOG_SOURCE_HOST) {
			// Get Time stamp. Parse format as given from wlan driver
			while (!(*ts_ptr == ']')) {
				if (*ts_ptr == '\0') {
					// Handle empty lines and multi line logs
					if (log->txt_len == 1)
						return;
					else
						goto skip_multi_ln_log_time;
				}
				ts_ptr++;
			}
			if (gwlan_dev == CNSS_DIAG_WLAN_ROM_DEV ||
				 gwlan_dev == CNSS_DIAG_WLAN_TUF_DEV) {
				sscanf(++ts_ptr, "[%02d:%02d:%02d.%06d",
						 &hh, &mm, &ss, &ts_us);
				log_time = ((hh * 3600 + mm * 60 + ss) * 1000) +
							(ts_us / 1000);
			} else {
				sscanf(++ts_ptr, "[%"PRIu64"]", &log_time);
				// Conv to milli sec
				log_time /= QTIMER_FREQ_KHZ;
			}
		} else {
			ts_ptr = strstr(log_txt_buf, "FWMSG");
			// Shift by 7 chars to move to Time stamp value ie "FWMSG: [%llu]"
			if (ts_ptr) {
				ts_ptr += strlen("FWMSG: ");
				sscanf(ts_ptr, "[%"PRIu64"]", &log_time);
			}
		}
skip_multi_ln_log_time:
		log->delta_time = log_time - cur_time;
	}
#if DIAG_KEEP_ORIG
	log->lvl = MSG_LEGACY_MED;
	if (log_source == LOG_SOURCE_HOST)
		log->ss_id = MSG_SSID_WLAN_RESERVED_10;
	else
		log->ss_id = MSG_SSID_WLAN;
#endif
	memcpy(log->txt, log_txt_buf, log_txt_len);
}

/* Convert WLAN text logs to containder log packet format for QXDM / APEX */
void cnss_conv_diag_log_packet(uint8_t log_source, char *orig_wlan_log_buf,
		uint32_t wlan_log_buf_len, int flag)
{
	struct cnss_log_pkt_buf *log_pkt_buf;
	struct cnss_diag_log_buf *diag_buf = NULL;
	struct cnss_diag_file_buf *diag_file_buf = NULL;
	int log_txt_len;
	uint64_t cur_time;
	char *wlan_log_buf, *wlan_log_buf_start, *wlan_log_buf_end,
		 *wlan_log_buf_ptr, *log_pkt_buf_ptr;

	wlan_log_buf_start = malloc(wlan_log_buf_len);
	if (!wlan_log_buf_start) {
		printf("Log buf copy failed\n");
		return;
	}
	wlan_log_buf = wlan_log_buf_start;
	memcpy(wlan_log_buf, orig_wlan_log_buf, wlan_log_buf_len);
	wlan_log_buf_end = wlan_log_buf + wlan_log_buf_len;
	wlan_log_buf_ptr = wlan_log_buf;

	if (flag == LOGFILE_QXDM_FLAG) {
		diag_file_buf = cnss_diag_buf_alloc(log_source);
		if (!diag_file_buf) {
			printf("log_alloc failed");
			goto err;
		}
		log_pkt_buf = (struct cnss_log_pkt_buf *)diag_file_buf->log_packet;
		diag_file_buf->chunk_length += sizeof(struct cnss_log_pkt_hdr);
	} else {
		diag_buf = cnss_diag_buf_alloc(log_source);
		if (!diag_buf) {
			printf("log_alloc failed");
			goto err;
		}
		log_pkt_buf = &diag_buf->log_pkt_buf;
	}
	cnss_diag_log_entry_cur_time(log_source, &cur_time);

	log_pkt_buf_ptr = (char *)log_pkt_buf + sizeof(struct cnss_log_pkt_hdr);

	while (wlan_log_buf_ptr < wlan_log_buf_end) {
		while ((*wlan_log_buf_ptr != '\n') &&
					(*wlan_log_buf_ptr != '\0') &&
					(wlan_log_buf_ptr <
					wlan_log_buf_end)) {
			++wlan_log_buf_ptr;
		}
		*wlan_log_buf_ptr++ = '\0';
		log_txt_len = strlen(wlan_log_buf) + 1;
		if (log_txt_len == 1) {
			wlan_log_buf = wlan_log_buf_ptr;
			continue;
		}
		// Check if adding next log_ent overflows max 6K and send log buffer to diag
		if (((log_pkt_buf_ptr - (char *)log_pkt_buf) +
				sizeof(struct cnss_log_ent) +
				log_txt_len) >= (CNSS_DIAG_LOG_BUF_MAX)) {
			if (flag == LOGFILE_QXDM_FLAG) {
				cnss_diag_log_commit(diag_file_buf, flag,
							log_source);
				memset(log_pkt_buf, 0, CNSS_DIAG_LOG_BUF_MAX);
				log_pkt_buf = (struct cnss_log_pkt_buf *)
						diag_file_buf->log_packet;
				log_pkt_buf->hdr.num_ent = 0;
			} else {
				cnss_diag_log_commit(diag_buf, flag, log_source);
				diag_buf = cnss_diag_buf_alloc(log_source);
				if (!diag_buf) {
					printf("log_alloc failed");
					goto err;
				}
				log_pkt_buf = &diag_buf->log_pkt_buf;
			}
		}
		cnss_diag_log_entry_create((struct cnss_log_ent *) log_pkt_buf_ptr,
					wlan_log_buf, log_source, cur_time);
		log_pkt_buf_ptr = log_pkt_buf_ptr +
				sizeof(struct cnss_log_ent) + log_txt_len;
		diag_file_buf->chunk_length += sizeof(struct cnss_log_ent) +
						log_txt_len;
		log_pkt_buf->hdr.num_ent++;
		wlan_log_buf = wlan_log_buf_ptr;
	}
	if (flag == LOGFILE_QXDM_FLAG) {
		cnss_diag_log_commit(diag_file_buf, flag, log_source);
		free(diag_file_buf);
	} else {
		cnss_diag_log_commit(diag_buf, flag, log_source);
	}
err:
	if (wlan_log_buf_start)
		free(wlan_log_buf_start);
}

uint16_t const crc_ccitt_table[256] = {
	0x0000, 0x1189, 0x2312, 0x329b, 0x4624, 0x57ad, 0x6536, 0x74bf,
	0x8c48, 0x9dc1, 0xaf5a, 0xbed3, 0xca6c, 0xdbe5, 0xe97e, 0xf8f7,
	0x1081, 0x0108, 0x3393, 0x221a, 0x56a5, 0x472c, 0x75b7, 0x643e,
	0x9cc9, 0x8d40, 0xbfdb, 0xae52, 0xdaed, 0xcb64, 0xf9ff, 0xe876,
	0x2102, 0x308b, 0x0210, 0x1399, 0x6726, 0x76af, 0x4434, 0x55bd,
	0xad4a, 0xbcc3, 0x8e58, 0x9fd1, 0xeb6e, 0xfae7, 0xc87c, 0xd9f5,
	0x3183, 0x200a, 0x1291, 0x0318, 0x77a7, 0x662e, 0x54b5, 0x453c,
	0xbdcb, 0xac42, 0x9ed9, 0x8f50, 0xfbef, 0xea66, 0xd8fd, 0xc974,
	0x4204, 0x538d, 0x6116, 0x709f, 0x0420, 0x15a9, 0x2732, 0x36bb,
	0xce4c, 0xdfc5, 0xed5e, 0xfcd7, 0x8868, 0x99e1, 0xab7a, 0xbaf3,
	0x5285, 0x430c, 0x7197, 0x601e, 0x14a1, 0x0528, 0x37b3, 0x263a,
	0xdecd, 0xcf44, 0xfddf, 0xec56, 0x98e9, 0x8960, 0xbbfb, 0xaa72,
	0x6306, 0x728f, 0x4014, 0x519d, 0x2522, 0x34ab, 0x0630, 0x17b9,
	0xef4e, 0xfec7, 0xcc5c, 0xddd5, 0xa96a, 0xb8e3, 0x8a78, 0x9bf1,
	0x7387, 0x620e, 0x5095, 0x411c, 0x35a3, 0x242a, 0x16b1, 0x0738,
	0xffcf, 0xee46, 0xdcdd, 0xcd54, 0xb9eb, 0xa862, 0x9af9, 0x8b70,
	0x8408, 0x9581, 0xa71a, 0xb693, 0xc22c, 0xd3a5, 0xe13e, 0xf0b7,
	0x0840, 0x19c9, 0x2b52, 0x3adb, 0x4e64, 0x5fed, 0x6d76, 0x7cff,
	0x9489, 0x8500, 0xb79b, 0xa612, 0xd2ad, 0xc324, 0xf1bf, 0xe036,
	0x18c1, 0x0948, 0x3bd3, 0x2a5a, 0x5ee5, 0x4f6c, 0x7df7, 0x6c7e,
	0xa50a, 0xb483, 0x8618, 0x9791, 0xe32e, 0xf2a7, 0xc03c, 0xd1b5,
	0x2942, 0x38cb, 0x0a50, 0x1bd9, 0x6f66, 0x7eef, 0x4c74, 0x5dfd,
	0xb58b, 0xa402, 0x9699, 0x8710, 0xf3af, 0xe226, 0xd0bd, 0xc134,
	0x39c3, 0x284a, 0x1ad1, 0x0b58, 0x7fe7, 0x6e6e, 0x5cf5, 0x4d7c,
	0xc60c, 0xd785, 0xe51e, 0xf497, 0x8028, 0x91a1, 0xa33a, 0xb2b3,
	0x4a44, 0x5bcd, 0x6956, 0x78df, 0x0c60, 0x1de9, 0x2f72, 0x3efb,
	0xd68d, 0xc704, 0xf59f, 0xe416, 0x90a9, 0x8120, 0xb3bb, 0xa232,
	0x5ac5, 0x4b4c, 0x79d7, 0x685e, 0x1ce1, 0x0d68, 0x3ff3, 0x2e7a,
	0xe70e, 0xf687, 0xc41c, 0xd595, 0xa12a, 0xb0a3, 0x8238, 0x93b1,
	0x6b46, 0x7acf, 0x4854, 0x59dd, 0x2d62, 0x3ceb, 0x0e70, 0x1ff9,
	0xf78f, 0xe606, 0xd49d, 0xc514, 0xb1ab, 0xa022, 0x92b9, 0x8330,
	0x7bc7, 0x6a4e, 0x58d5, 0x495c, 0x3de3, 0x2c6a, 0x1ef1, 0x0f78
};

static inline uint16_t crc_ccitt_byte(uint16_t crc, const uint8_t c)
{
	return (crc >> 8) ^ crc_ccitt_table[(crc ^ c) & 0xff];
}

static uint16_t crc_ccitt(uint16_t crc, uint8_t const *buffer, size_t len)
{
	while (len--)
		crc = crc_ccitt_byte(crc, *buffer++);
	return crc;
}

void buffer_fw_logs_log_pkt(char *fw_log, boolean force)
{
#if DIAG_KEEP_ORIG
	static char *fw_buf, *fw_buf_ptr;
	static int free_buf_mem;
	int log_len;
#define FW_LOG_COLLECTION_BUF_SIZE 4096
	// One time alloc during first logging.
	if (!fw_buf) {
		fw_buf = malloc(FW_LOG_COLLECTION_BUF_SIZE);
		if (!fw_buf)
			return;
		fw_buf_ptr = fw_buf;
		free_buf_mem = FW_LOG_COLLECTION_BUF_SIZE;
	}
	log_len = strlen(fw_log);

	if (free_buf_mem < log_len || force) {
		cnss_conv_diag_log_packet(LOG_SOURCE_FW, fw_buf,
				(fw_buf_ptr - fw_buf), LOGFILE_QXDM_FLAG);
		fw_buf_ptr = fw_buf;
		free_buf_mem = FW_LOG_COLLECTION_BUF_SIZE;
		memset(fw_buf_ptr, 0, free_buf_mem);
	}
	memcpy(fw_buf_ptr, fw_log, log_len);
	fw_buf_ptr += log_len;
	free_buf_mem -= log_len;
	if (force) {
		free(fw_buf);
		fw_buf = NULL;
	}
#else
	UNUSED(fw_log);
	UNUSED(force);
#endif
}

#if DIAG_KEEP_ORIG
static t_buffer *add_new_buff(t_buffer *current, int length)
{
	t_buffer *new_buffer = NULL;

	new_buffer = (t_buffer *) malloc(sizeof(t_buffer));
	if (new_buffer == NULL)
		return NULL;
	memset(new_buffer, 0x00, sizeof(t_buffer));

	new_buffer->start = (unsigned char *) malloc(length);
	if (new_buffer->start == NULL) {
		free(new_buffer);
		return NULL;
	}
	new_buffer->end = new_buffer->start;

	new_buffer->next = current->next;
	current->next = new_buffer;

	return new_buffer;
}
#endif

/* Buffers firmware and driver logs */
static void cnss_logs_to_buffer(int bytes_read, char *read_data, enum fileType type)
{
#if DIAG_KEEP_ORIG
	int available_space;
	struct cnss_log_file_data *lfd;
	t_buffer *buffer_log = NULL;

	if (type >= LOG_FILE_MAX)
		return;
	if (bytes_read > EACH_BUF_SIZE) {
		android_printf("Unexpected huge buffer received");
		return;
	}
	lfd = &log_file[type];
	pthread_mutex_lock(&lfd->buff_lock);
	buffer_log = (t_buffer *)lfd->buf_ptr;
	available_space = EACH_BUF_SIZE - (buffer_log->end - buffer_log->start);

	if (bytes_read > available_space) {
		if (lfd->num_buffers_occupied < max_no_buffer) {
			t_buffer *new_buffer;

			new_buffer = add_new_buff(buffer_log, EACH_BUF_SIZE);
			if (new_buffer) {
				lfd->num_buffers_occupied++;
				buffer_log = new_buffer;
			} else {
				/* If malloc fails write into the oldest buf */
				buffer_log = buffer_log->next;
				buffer_log->end = buffer_log->start;
			}
		} else {
			buffer_log = buffer_log->next;
			buffer_log->end = buffer_log->start;
		}
	}

	memcpy(buffer_log->end, read_data, bytes_read);
	buffer_log->end += bytes_read;
	lfd->buf_ptr =(char*) buffer_log;
	pthread_mutex_unlock(&lfd->buff_lock);
#else
	UNUSED(bytes_read);
	UNUSED(read_data);
	UNUSED(type);
#endif
}

static int
diag_printf(const char *buf,  uint16_t vdevid,  uint16_t level,
            uint32_t optionflag, uint64_t timestamp, FILE *fp,
            uint32_t radio_id)
{
	char pbuf[MAX_SIZE];
	char pfilebuf[MAX_SIZE];
	int bytes_copied = 0;
	char tmbuf[TIME_DATA_SIZE];

	UNUSED(level);
	//appendLocalTime(tmbuf);

	snprintf(pbuf, MAX_SIZE, "R%d: FWMSG: [%" PRIu64 "] vap-%u %s", radio_id, timestamp,
								 vdevid, buf);

	if (optionflag & CONSOLE_FLAG) {
		android_printf("%s\n", pbuf);
	}
	if ((optionflag & LOGFILE_FLAG) && fp) {
		if (!((optionflag & SILENT_FLAG) ==
		       SILENT_FLAG))
			printf("%ld: %s\n", (fp != NULL) ? ftell(fp): 0, buf);

		bytes_copied = snprintf(pfilebuf, MAX_SIZE, "%s %s\n", tmbuf, pbuf);

		if (optionflag & LOGFILE_FLAG)
			cnss_write_buf_logs(bytes_copied, pfilebuf, FW_LOG_FILE);
	}
	if (optionflag & LOG_BUFF_FLAG && optionflag & DECODED_LOG_FLAG) {
		bytes_copied = snprintf(pfilebuf, MAX_SIZE, "%s %s\n", tmbuf, pbuf);
		cnss_logs_to_buffer(bytes_copied, pfilebuf, BUFFER_FW_FILE);
	}
	return 0;
}

/*
 * database initialization
 */
static void
diag_create_db(uint32_t n_entries, uint32_t radio_id)
{
	/* TODO: Memory may leak */
	if (radio_id < NUM_OF_DRIVERS && gdiag_header[radio_id] == NULL) {
		gdiag_header[radio_id] = calloc(1, sizeof(*gdiag_header[radio_id]));
		if (!gdiag_header[radio_id])
			return;
		gdiag_header[radio_id]->n_entries = n_entries;
		gdiag_db[radio_id] = calloc(gdiag_header[radio_id]->n_entries, sizeof(*gdiag_db[radio_id]));
		if (!gdiag_db[radio_id])
			return;
		/* hash */
		gdiag_header[radio_id]->hash = (gdiag_header[radio_id]->n_entries % 2 == 0) ?  \
			gdiag_header[radio_id]->n_entries / 2 :                      \
			(gdiag_header[radio_id]->n_entries + 1) / 2;
	}
}

/*
 * database free
 */
static void
diag_free_db()
{
	int32_t count = 0, radio_id;
	diag_entry *diag_db = NULL;
	file_header *diag_header = NULL;
	int32_t *isdiag_init = NULL;
	for (radio_id = 0; radio_id < NUM_OF_DRIVERS; radio_id++) {
		diag_db = gdiag_db[radio_id];
		diag_header = gdiag_header[radio_id];
		isdiag_init = &gisdiag_init[radio_id];
		if (diag_db && diag_header) {
			for (count = 0; count < diag_header->n_entries; count++) {
				if (diag_db[count].isUsed){
					if (diag_db[count].format)
						free(diag_db[count].format);
					if (diag_db[count].pack)
						free(diag_db[count].pack);
				}
			}
		}
		if (diag_db)
			free(diag_db);
		gdiag_db[radio_id] = NULL;
		if (diag_header)
			free(diag_header);
		gdiag_header[radio_id] = NULL;
		if (isdiag_init)
			*isdiag_init = FALSE;
	}
}

/*
 * insert into database
 */
static int32_t
diag_insert_db(char *format, char *pack, uint32_t id, uint32_t radio_id)
{
	file_header *diag_header = NULL;
	diag_entry *diag_db = NULL;

	if (radio_id < NUM_OF_DRIVERS) {
		if (!gdiag_header[radio_id]) {
			android_printf("%s: gdiag_header for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_header = gdiag_header[radio_id];
		diag_db = gdiag_db[radio_id];

		/* Double Hashing  */
		int32_t i = id % diag_header->n_entries;
		int32_t j = diag_header->hash - (id % diag_header->hash);

		if (diag_header->n_entries == diag_header->n_usedEntries) {
			printf("db is full");
			return 0;
		}

		/* search */
		while (diag_db[i].isUsed) {
			i = (i + j)%diag_header->n_entries;
		}

		diag_db[i].id = id;
		diag_db[i].format = format;
		diag_db[i].pack = pack;
		diag_db[i].isUsed = TRUE;
		diag_header->n_usedEntries++;
		return 1;
	} else {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}
}

/*
 * parser looks up entry at runtime based on 'id' extracted from FW
 * message
 */
static diag_entry*
diag_find_by_id(uint32_t id, uint32_t radio_id)
{
	boolean isfound = FALSE;
	int32_t count = 0;
	int32_t i;
	int32_t j;
	file_header *diag_header = NULL;
	diag_entry *diag_db = NULL;

	if (radio_id < NUM_OF_DRIVERS) {
		if (!gdiag_header[radio_id]) {
			android_printf("%s: gdiag_header for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_header = gdiag_header[radio_id];
		if (!gdiag_db[radio_id]) {
			android_printf("%s: gdiag_db for radio_id %d is NULL\n",
				__func__, radio_id);
			return 0;
		}
		diag_db = gdiag_db[radio_id];

		i = id % diag_header->n_entries;
		j = diag_header->hash - (id % diag_header->hash);
		if (diag_header->n_usedEntries == 0) {
			return NULL;
		}
		while (diag_db[i].isUsed != 0 && count <= diag_header->n_entries) {
			if (diag_db[i].id == id) {
				isfound = TRUE;
				break;
			}
			i = (i + j) % diag_header->n_entries;
			count++;
		}
		if (!isfound) {
			debug_printf("Not found in data base\n");
			return NULL;
		}
		return &diag_db[i];
	} else {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}
}

/* user  supply their own function to build string in temporary
 * buffer
 */
static void dbg_write_char(char **pbuf_start, char *buf_end, char c)
{
	if ( *pbuf_start < buf_end) {
		*(*pbuf_start) = c;
		++(*pbuf_start);
	}
}

static uint32_t
get_numberofentries(int32_t radio_id, char *db_parse_path, uint32_t decrement)
{
	FILE* fd = NULL;
	char line[1024];
	int32_t n_entries = 0, i = 0;
	boolean  isfound = FALSE;

	if (radio_id < NUM_OF_DRIVERS) {
		if (radio_id == 0) {
			if ((fd = fopen(db_parse_path, "r")) == NULL) {
				printf("[Error] : While opening db file\n");
				return 0;
			}
		} else if (radio_id == 1) {
		}

		if (fd == NULL) {
			debug_printf("%s: fd is NULL\n", __func__);
			return 0;
		}
		while ( fgets (line, sizeof(line), fd) != NULL ) {
			n_entries++;
		}

		/* Decrement 1 for version and the last line /r/n */
		n_entries -= decrement;

		/* check if n_entries is prime number else change to prime number */
		while (1) {
			for (i = 2; i < n_entries; i++) {
				if ( n_entries % i == 0 ) {
					/* n_entries is divisible, break for loop */
					isfound = TRUE;
					break;
				}
			}
			if (!isfound && n_entries > 2)
				break;
			isfound = FALSE;
			/* Increment n_entries and check is it prime number */
			n_entries++;
		}
		fclose(fd);
		debug_printf( "Number of entries is %d\n", n_entries);
		return n_entries;
	} else {
		diag_printf("Invalid radio_id.\n", 0, 0, 0, 0, 0, 0);
		return 0;
	}
}

static uint32_t
parse_napier_dbfile(uint32_t radio_id)
{
	FILE* fd = NULL;
	uint32_t n_entries = 0;
	uint32_t id = 0;
	char *p = NULL, *pack = NULL, *format = NULL;
	/* TODO: temperarily move to static to avoid stack overflow */
	static char line[1024];
	char *save;
	n_entries = get_numberofentries(radio_id, napier_db_parse_path, NAPIER_DB_META_LINE);
	diag_create_db(n_entries, radio_id);
	n_entries = 0;

	if (radio_id >= NUM_OF_DRIVERS) {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}

	if (!gdiag_header[radio_id]) {
		android_printf("%s: gdiag_header for radio_id %d is NULL\n",
			__func__, radio_id);
		return 0;
	}

	/* Open the data.msc file for the correct radio driver */
	if (radio_id == 0) {
		if ((fd = fopen(napier_db_parse_path, "r")) == NULL) {
			printf("[Error] : fail to open db file\n");
			return 0;
		}
	} else if (radio_id == 1) {
		return 0;
	}

	memset(line, 0 , sizeof(line));
	while ( fgets (line, sizeof(line), fd) != NULL ) {
		n_entries++;
		if (n_entries <= NAPIER_DB_META_LINE) {
			/* TODO: Parse for the version */
			continue;
		} else {
			p = strtok_r(line, ":", &save);
			if (p)
				id = strtoul(p, (char **)NULL, 10);
			else
				continue;

			p = strtok_r(NULL, ":", &save);
			if (p)
				pack = strdup(p);
			else
				continue;

			p = strtok_r(NULL, "\r", &save);

			if (p)
				format = strdup(p);
			else
				continue;

			if (!diag_insert_db(format, pack, id, radio_id)) {
				fclose(fd);
				return 0;
			}
		}
		memset(line, 0 , sizeof(line));
	}
	fclose(fd);
	return n_entries;
}

static uint32_t
parse_legacy_dbfile(uint32_t radio_id)
{
        FILE* fd = NULL;
        uint32_t n_entries = 0;
        uint32_t id = 0;
        char line[1024], *p = NULL, *pack = NULL, *format = NULL;
        char pbuf[128], *q = NULL;
        char *save;
        n_entries = get_numberofentries(radio_id, legacy_db_parse_path, LEGACY_DB_META_LINE);
        diag_create_db(n_entries, radio_id);
        n_entries = 0;
        file_header *diag_header = NULL;

        if (radio_id >= NUM_OF_DRIVERS) {
                android_printf("%s: invalid radio_id %d.\n",
                        __func__, radio_id);
                return 0;
        }

        if (!gdiag_header[radio_id]) {
                android_printf("%s: gdiag_header for radio_id %d is NULL\n",
                        __func__, radio_id);
                return 0;
        }
        diag_header = gdiag_header[radio_id];

        /* Open the data.msc file for the correct radio driver */
        if (radio_id == 0) {
                if ((fd = fopen(legacy_db_parse_path, "r")) == NULL) {
                        diag_printf("[Error] : While opening driver 1 file\n",
			    0, 4, goptionflag, 0, NULL, radio_id);
                        return 0;
                }
        } else if (radio_id == 1) {
			return 0;
        }
        memset(line, 0 , sizeof(line));
        while ( fgets (line, sizeof(line), fd) != NULL ) {
                n_entries++;
                if (n_entries == 1) {
                        /* Parse for the version */
                        p = strstr(line, "VERSION:");
                        if (p) {
                                p += strlen("VERSION:");
                                diag_header->file_version = (int32_t)strtol(p, (char **)NULL, 10);
                        }
                        else {
                                fclose(fd);
                                return 0;
                        }
                } else {
                        p = strtok_r(line, ",", &save);
                        if (p)
                                id = (uint32_t)strtol(p, (char **)NULL, 10);
                        else
                                continue;

                        p = strtok_r(NULL, ",", &save);
                        if (p)
                                pack = strdup(p);
                        else
                                continue;

                        p = strtok_r(NULL, "\r", &save);
                        if (p) {
                                format = strdup(p);
                                if (format) {
                                        /* Check for CR */
                                        p = strstr(format, "\r");
                                        if (p)
                                                *p = '\0';
                                        else {
                                                p = strstr(format, "\n");
                                                if (p)
                                                        *p = '\0';
                                        }
                                }
                        } else {
                                /* Else CASE for pack specifier is 0  */
                                if (pack) {
                                        /* Check for CR */
                                        p = strstr(pack, "\r");
                                        if (p)
                                                *p = '\0';
                                        else {
                                                p = strstr(pack, "\n");
                                                if (p)
                                                        *p = '\0';
                                        }
                                        format = pack;
                                        pack = NULL;
                                }
                        }
                        /* Go through the pack specifier, to find
                           pack with number */
                        if (pack) {
                                q = pack;
                                format_pack(pack, pbuf, sizeof(pbuf));
                                pack = strdup(pbuf);
                                free(q);
                        }
                        if (!diag_insert_db(format, pack, id, radio_id)) {
                                fclose(fd);
                                return 0;
                        }
                }
                memset(line, 0 , sizeof(line));
        }
        fclose(fd);
        return n_entries;
}

static uint32_t
parse_dbfile(uint32_t radio_id)
{
	if (!access(napier_db_parse_path, F_OK)) {
		return parse_napier_dbfile(radio_id);
	}
	else if (!access(legacy_db_parse_path, F_OK)) {
		return parse_legacy_dbfile(radio_id);
	} else {
		return -1;
	}
}

#if DIAG_KEEP_ORIG


static int32_t
sendcnss_cmd(int sock_fd, int32_t cmd, int len, uint8_t *buf)
{
	struct dbglog_slot *slot;
	struct sockaddr_nl dest_addr;
	struct nlmsghdr *nlh = NULL;
	struct msghdr msg;
	struct iovec iov;
	int32_t ret, slot_len = 0;

	slot_len =  sizeof(struct dbglog_slot) + len;
	char *slot_buf = NULL;
	slot_buf = malloc(slot_len);
	if (slot_buf == NULL) {
		fprintf(stderr, "Cannot allocate slot memory \n");
		return -1;
	}
	slot = (struct dbglog_slot *)slot_buf;
	memset(slot, 0 , sizeof(struct dbglog_slot));
	slot->diag_type = cmd;
	slot->length = len;
	memcpy(slot->payload, buf, len);

	memset(&dest_addr, 0, sizeof(dest_addr));
	dest_addr.nl_family = AF_NETLINK;
	dest_addr.nl_pid = 0; /* For Linux Kernel */
	dest_addr.nl_groups = 0; /* unicast */

	nlh = malloc(NLMSG_SPACE(slot_len));
	if (nlh == NULL) {
		fprintf(stderr, "Cannot allocate memory \n");
		free(slot_buf);
		return -1;
	}
	memset(nlh, 0, NLMSG_SPACE(slot_len));
	nlh->nlmsg_len = NLMSG_SPACE(slot_len);
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_type = WLAN_NL_MSG_CNSS_DIAG;
	nlh->nlmsg_flags = NLM_F_REQUEST;

	memcpy(NLMSG_DATA(nlh), slot_buf, slot_len);
	free(slot_buf);

	memset(&msg, 0, sizeof(msg));
	iov.iov_base = (void *)nlh;
	iov.iov_len = nlh->nlmsg_len;
	msg.msg_name = (void *)&dest_addr;
	msg.msg_namelen = sizeof(dest_addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	ret  = sendmsg(sock_fd, &msg, 0);
	free(nlh);
	return ret;
}
#endif

void
diag_initialize(int sock_fd, uint32_t optionflag)
{
	uint32_t ret, radio_id;

	UNUSED(sock_fd);
	UNUSED(optionflag);
	//goptionflag = optionflag;

	diag_free_db();
	for (radio_id = 0; radio_id < NUM_OF_DRIVERS; radio_id++) {
		ret = parse_dbfile(radio_id);
		if (ret > 1)
			gisdiag_init[radio_id] = TRUE;
		else
			gisdiag_init[radio_id] = FALSE;
	}
	//gdiag_sock_fd = sock_fd;
}

#if DIAG_KEEP_ORIG
void
process_diaghost_msg(uint8_t *datap, uint16_t len)
{
	uint8_t  *payload;
	UNUSED(len);
	event_report_t *pEvent_report =(event_report_t *)datap ;
	if (!pEvent_report)
		return;
	debug_printf("\n  %s diag_type = %d event_id =%d\n",
		     __func__, pEvent_report->diag_type,
		     pEvent_report->event_id);
	if (pEvent_report->diag_type == DIAG_TYPE_EVENTS) {
		payload = datap + sizeof(event_report_t);
		event_report_payload(pEvent_report->event_id,
				     pEvent_report->length, payload);
	}
}
#endif

void
process_diagfw_diagtypeconfig(uint32_t id, char *payload,
							  uint32_t payloadlen)
{
	switch (id) {
	case DIAG_VERSION_INFO:
		/* Not doing anything here since driver has already parsed this */
		debug_printf("%s id=DIAG_VERSION_INFO payloadlen=%d",
					 __func__, payloadlen);
		break;
	case DIAG_BASE_TIMESTAMP:
		base_timestamp = *((uint64_t *)payload);
		debug_printf("%s id=DIAG_BASE_TIMESTAMP payloadlen=%d "
					 "base_timestamp=%" PRIu64,
					 __func__, payloadlen,
					 base_timestamp);
		break;
	default:
		debug_printf("%s unhandled id=%d payloadlen=%d",
					 __func__, id, payloadlen);
		break;
	}
}
uint32_t
process_diagfw_msg(uint8_t *datap, uint16_t len, uint32_t optionflag,
    int32_t version, int sock_fd, uint32_t radio_id)
{
	uint32_t count = 0, index = 0, offset = 0;
	uint64_t timestamp = 0;
	uint32_t diagid = 0, id = 0;
#if DIAG_KEEP_ORIG
	uint32_t moduleid = 0;
#endif
	uint32_t num_buf = 0, payloadlen = 0;
	uint16_t vdevid = 0, vdevlevel = 0;
	uint32_t *buffer;
	uint32_t header1 = 0, header2 = 0;
	char *payload;
	char buf[BUF_SIZ], payload_buf[BUF_SIZ];
	char *start = buf;
	int32_t i =0, j =0;
	diag_entry *entry = NULL;
	int ret = 0, total_dump_len = 0;
	uint8_t *debugp = datap;
	char dump_buffer[BUF_SIZ];
	uint32_t read_count = 0;
	file_header *diag_header = NULL;

	if (optionflag & DEBUG_FLAG) {
		memset(dump_buffer, 0, sizeof(dump_buffer));
		debug_printf("process_diagfw_msg hex dump start len %d", len);
		for (i = 0; i < len; i++) {
			ret = snprintf(dump_buffer + j, BUF_SIZ - j,
				       "0x%x ", debugp[i]);
			j += ret;
			if (!(i % 16) && (i!=0)) {
				total_dump_len += 16;
				debug_printf("%s", dump_buffer);
				memset(dump_buffer, 0, sizeof(dump_buffer));
				j = 0;
			}
		}
		if (total_dump_len != len)
			debug_printf("%s", dump_buffer);
		debug_printf("process_diagfw_msg hex dump end");
	}

	if (radio_id >= NUM_OF_DRIVERS) {
		android_printf("%s: invalid radio_id %d.\n",
			__func__, radio_id);
		return 0;
	}

	if (!gisdiag_init[radio_id]) {
		/* If cnss_diag is started if WIFI already ON,
		* then turn on event not received hence
		* before throwing out error initialize again
		*/
		diag_initialize(sock_fd, optionflag);
		if (!gisdiag_init[radio_id]) {
			diag_printf("**ERROR** Diag not initialized for radio/driver",
			    0, 4, optionflag, 0, NULL, radio_id);
			return -1;
		}
	}

	buffer = (uint32_t *)datap;
	buffer ++; /* increment 1 to skip dropped */
	num_buf = len - 4;
	debug_printf("\n --%s-- %d\n", __FUNCTION__, optionflag);

	if (!gdiag_header[radio_id]) {
		android_printf("%s: gdiag_header for radio_id %d is NULL\n",
			__func__, radio_id);
		return 0;
	}
	diag_header = gdiag_header[radio_id];

	while (num_buf  > count) {
		header1 = *(buffer + index);
		diagid  = DIAG_GET_TYPE(header1);
		offset = 1;
		if (diagid > WLAN_DIAG_TYPE_LEGACY_MSG) {
			/*
			   This would mean 64 bit timestamp value to be calculated.
			   Offset of header2 will be one more than the earlier case as
			   there is 32 bit timestamp offset in the next word.
			   Also increment the count by 4.
			*/
			timestamp = (uint32_t)(*(buffer + index + offset));
			offset++;
			count += 4;
		} else {
			timestamp = DIAG_GET_TIME_STAMP(header1);
		}
		timestamp += base_timestamp;
		header2 = *(buffer + offset + index);
		payload = (char *)(buffer + offset + 1 + index);
		/* Incrementing the count by 8 to start of payload */
		count += 8;
		payloadlen = 0;
		debug_printf("diagid = %d  timestamp = %" PRIu64
			     " header1 = %x header2 = %x\n",
			     diagid,  timestamp, header1, header2);
		switch (diagid) {
		case WLAN_DIAG_TYPE_EVENT_V2:
		case WLAN_DIAG_TYPE_EVENT:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN16(header2);
			debug_printf("DIAG_TYPE_FW_EVENT: id = %d"
				     " payloadlen = %d \n", id, payloadlen);
#if DIAG_KEEP_ORIG
			if (optionflag & QXDM_FLAG) {
				if (payloadlen)
					event_report_payload(id,
					    payloadlen, payload);
				else
					event_report(id);
			}
#endif
		}
		break;
		case WLAN_DIAG_TYPE_LOG:
		case WLAN_DIAG_TYPE_LOG_V2:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN16(header2);
			debug_printf("DIAG_TYPE_FW_LOG: id = %d"
			    " payloadlen = %d \n", id,  payloadlen);
#if DIAG_KEEP_ORIG
			if (optionflag & QXDM_FLAG) {
				/* Allocate a log buffer */
				uint8_t *logbuff = (uint8_t*) log_alloc(id,
				    sizeof(log_hdr_type)+payloadlen);
				if ( logbuff != NULL ) {
					/* Copy the log data */
					memcpy(logbuff + sizeof(log_hdr_type),
					       payload,
					       payloadlen);
					/* Commit the log buffer */
					log_commit(logbuff);
				}
				else
					debug_printf("log_alloc failed"
						     "for len = %d ",
					             payloadlen);
			}
# endif
		}
		break;
		case WLAN_DIAG_TYPE_MSG:
		case WLAN_DIAG_TYPE_MSG_V2:
		{
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN(header2);
			vdevid = DIAG_GET_VDEVID(header2);
			vdevlevel = DIAG_GET_VDEVLEVEL(header2);
			memset(buf, 0, BUF_SIZ);
			memset(payload_buf, 0, BUF_SIZ);
			debug_printf("R%d: DIAG_TYPE_FW_DEBUG_MSG: "
			    " vdevid %d vdevlevel %d payloadlen = %d id = %d\n",
			    radio_id, vdevid, vdevlevel, payloadlen, id);
			if (diag_header->file_version != version) {
				snprintf(buf, BUF_SIZ, "**ERROR**"
				    "R%d: Data.msc Version %d doesn't match"
				    " with Firmware version %d id = %d",
				    radio_id, diag_header->file_version, version, id);
				diag_printf(buf, 0, 4, optionflag, 0, NULL, radio_id);
				break;
			}
			entry = diag_find_by_id(id, radio_id);
			if (entry) {
				if ((payloadlen > 0) && (entry->format && entry->pack)) {
					debug_printf("entry->format = %s"
						     " pack = %s\n",
						     entry->format,
						     entry->pack);
					if (payloadlen < BUF_SIZ)
						memcpy(payload_buf,
						       payload, payloadlen);
					else
						memcpy(payload_buf,
						       payload, BUF_SIZ);
					/* Sending with BUF_SIZ to pack_printf
					 * because some times payloadlen
					 * received doesnt match with the pack
					 * specifier, in that case just print
					 * the zero
					 */
					entry->msg_len = BUF_SIZ;
					entry->msg = payload_buf;
					start = buf;
					pack_printf(
					    dbg_write_char,
					    &start,
					    start + sizeof(buf),
					    entry->format,
					    entry->pack,
					    (uint8_t*)entry->msg,
					    entry->msg_len);
				} else if (entry->format)
					//strlcpy(buf, entry->format,
					//	strlen(entry->format));

				debug_printf("\n buf = %s \n", buf);
				diag_printf(buf, vdevid, vdevlevel, optionflag,
					timestamp, log_file[FW_LOG_FILE].fp,
					radio_id);
			} else {
#if DIAG_KEEP_ORIG
				switch (id) {
				case DIAG_WLAN_MODULE_STA_PWRSAVE:
				case DIAG_WLAN_MODULE_WAL:
				case DIAG_NAN_MODULE_ID:
				case DIAG_WLAN_MODULE_IBSS_PWRSAVE:
					if (!diag_msg_handler(id, payload,
					        vdevid, timestamp, radio_id)) {
						snprintf(buf, BUF_SIZ,
						    "****WARNING****, undefined"
						    " moduleid = %d not"
						    " found", moduleid);
						diag_printf(buf, 0, 4,
						     optionflag, timestamp,
						     NULL, radio_id);
					}
					break;
				default:
					snprintf(buf, BUF_SIZ,
					    "****WARNING****, FWMSG ID %d"
					    " not found", id);
					diag_printf(buf, 0, 4, optionflag,
					     timestamp, NULL, radio_id);
					printf( "NOT found id = %d\n", id);
				}
#endif
			}
		}
		break;
		case WLAN_DIAG_TYPE_CONFIG:
			id = DIAG_GET_ID(header2);
			payloadlen = DIAG_GET_PAYLEN(header2);
			process_diagfw_diagtypeconfig(id, payload, payloadlen);
			break;
		default:
			diag_printf(" ****WARNING**** WRONG DIAG ID", 0,
			    4, optionflag, timestamp, NULL, radio_id);
			return 0;
		}
		count += payloadlen;
		if (optionflag & LOG_BUFF_FLAG &&
		    !(optionflag & DECODED_LOG_FLAG)) {
			cnss_logs_to_buffer(count - read_count,
					    (char *)(buffer + index),
					    BUFFER_FW_FILE);
			read_count = count;
		}
		index = count >> 2;
		debug_printf("Loop end:id = %d  payloadlen = %d"
			     " count = %d index = %d\n",
			     id,  payloadlen,  count, index);
	}

	return (0);
}

#if DIAG_KEEP_ORIG
/*
WLAN trigger command from QXDM

1) SSR
   send_data 75 41 7 0 1 0 253 len id val1 val 2
   id is subsystem id value
2) log level
   send_data 75 41 7 0 2 0 253 1 25

75 - DIAG_SUBSYS_CMD_F
41 - DIAG_SUBSYS_WLAN
0007 - CNSS_WLAN_DIAG
1 -  CMD type
FC00 - VS Command OpCode

*/

void * cnss_wlan_handle(void *req_pkt, uint16_t pkt_len)
{
	void *rsp = NULL;
	uint8_t *pkt_ptr = (uint8_t *)req_pkt + 4;
	uint16_t p_len, p_opcode;
	int32_t ret = 0, i = 0;
	char cmd[BUF_SIZ] = {0};

	/* Allocate the same length as the request
	   */
	rsp = diagpkt_subsys_alloc( DIAG_SUBSYS_WLAN, CNSS_WLAN_DIAG, pkt_len);
	if (rsp != NULL && pkt_len > 3) {
		p_len = *(pkt_ptr+3); /* VS Command packet length */
		p_opcode = (*(pkt_ptr+2) << 8) | *(pkt_ptr+1);
		debug_printf(
		    "%s : p_len: %d, pkt_len -8: %d, p_opcode:%.04x"
		    " cmd = %d\n",
		    __func__, p_len, pkt_len -8, p_opcode,
		    *pkt_ptr);
		if (p_len !=(pkt_len - 8) || ( p_opcode != 0xFD00)) {
			debug_printf("%s:Error in p_len or p_opcode ",
			    __func__);
			return rsp;
		}
		memcpy(rsp, req_pkt, pkt_len);
		if (*pkt_ptr == CNSS_WLAN_SSR_TYPE && p_len > 1) {
			/* get ID */
			i = *(pkt_ptr+4);
			p_len--;
			/* Restart for subsystem id */
			memset(cmd, 0x00, BUF_SIZ);
			snprintf(cmd, sizeof(cmd), RESTART_LEVEL, i);
			debug_printf("%s: cmd = %s\n", __func__, cmd);
			if ((ret = system(cmd))){
				if (ret <  0) {
					debug_printf("%s: error with subsystem"
						     " id\n", __func__);
					return rsp;
				}
			}
			if (gdiag_sock_fd > 0) {
				sendcnss_cmd(gdiag_sock_fd,
				    DIAG_TYPE_CRASH_INJECT,
				    p_len, (pkt_ptr + 5));
				debug_printf("%s: Success with crash inject \n",
				     __func__);
			}
		} else
			debug_printf("%s:Error in Command ", __func__ );
	} else
		debug_printf("%s:Allocate response buffer error", __func__ );
	return rsp;
}

void printLocalTime(FILE *fp, const char *prefix, const char *suffix)
{
	if (NULL != fp) {
		struct timeval tv;
		time_t now;
		char tmbuf[100];
		struct tm *qtm;
		gettimeofday(&tv, NULL);
		now = tv.tv_sec;
		qtm = localtime(&now);
		if (qtm) {
			if (suffix == NULL || prefix == NULL) {
				strftime(tmbuf, sizeof(tmbuf), "%H:%M:%S", qtm);
				fprintf(fp, "%s.%06d  ", tmbuf, (int)tv.tv_usec);
			} else {
				strftime(tmbuf, sizeof(tmbuf), "%Y-%m-%d %H:%M:%S", qtm);
				fprintf(fp, "%s%s.%06d %s", prefix, tmbuf, (int)tv.tv_usec, suffix);
			}
			if (ftell(fp) >= max_file_size) {
				fflush(fp);
				backup_file(HOST_LOG_FILE);
				cnss_open_log_file(TRUE, HOST_LOG_FILE);
				fclose(fp);
			}
		}
	}
}

/*assumes always length is multiple of 8 */
static void hexDumpPacket(char *p, char *pkt, unsigned int len)
{
	unsigned int i;
	char *_p, *_pkt;

	for (i = 0; i < (len/8); i++) {
		_p = &p[24*i]; _pkt = &pkt[8*i];
		HEXDUMP_PKT8(_p, _pkt);
	}
	return;
}
#endif

void process_cnss_host_message(tAniCLDHdr *wnl, int32_t optionflag)
{
	char *wlanLog = (char *)&wnl->wmsg.length + sizeof(wnl->wmsg.length);
	char *charCache = NULL;
	//char pktBuf[PKT_BUF_SIZE];
	//int i, npkt, bytes;
	//unsigned int frameSize;
	int bytes_copied = 0;
	char tmbuf[TIME_DATA_SIZE];
	char pbuf[MAX_SIZE];

	if (!wlanLog)
		return;

	if (wnl->wmsg.type == ANI_NL_MSG_LOG_HOST_MSG_TYPE) {
		char *wend = wlanLog + wnl->wmsg.length;
		charCache = wlanLog;
		if(optionflag & LOGFILE_QXDM_FLAG)
			cnss_conv_diag_log_packet(LOG_SOURCE_HOST, wlanLog,
				wnl->wmsg.length, LOGFILE_QXDM_FLAG);

		while (wlanLog < wend) {
			while ((*charCache != '\n') && (*charCache != '\0') &&
				 (charCache < wend)) {
				++charCache;
			}
			*charCache = '\0';

			if (optionflag & CONSOLE_FLAG) {
				android_printf("%s\n", wlanLog);
			}

			if (optionflag & LOGFILE_FLAG) {
				if (NULL != log_file[HOST_LOG_FILE].fp) {
					if (!((optionflag & SILENT_FLAG) == SILENT_FLAG))
						printf("%ld: %s\n", ftell(log_file[HOST_LOG_FILE].fp), wlanLog);
					appendLocalTime(tmbuf);
					if (*wlanLog != '\0') {
						bytes_copied = snprintf(pbuf, MAX_SIZE, "%s %s\n", tmbuf, wlanLog);
						cnss_write_buf_logs(bytes_copied, pbuf, HOST_LOG_FILE);
					}
				}
			}
#if DIAG_KEEP_ORIG
			if (optionflag & LOG_BUFF_FLAG) {
				appendLocalTime(tmbuf);
				if (*wlanLog != '\0') {
					bytes_copied = snprintf(pbuf, MAX_SIZE,
								"%s %s\n",
								tmbuf, wlanLog);
				cnss_logs_to_buffer(bytes_copied,
						    pbuf, BUFFER_HOST_FILE);
				}
			}
#endif
			wlanLog = ++charCache;
		}
#if DIAG_KEEP_ORIG
	} else if(wnl->wmsg.type == ANI_NL_MSG_LOG_MGMT_MSG_TYPE) {
		/* Pkt Message received
		* tAniNlHdr + (uint)frameSize + pkt data
		* The PTT_WLAN_LOG_PKT_MSG message hold 'n' pkts of
		* frameSize bytes each
		*/
		/* Handle management packet logs for pronto */
		frameSize = *(unsigned int *)wlanLog;
		wlanLog += sizeof(frameSize);
		npkt = wnl->wmsg.length / frameSize;

		debug_printf("Received npkt (%d) frameSize (%u)to dump\n",
			npkt, frameSize);
		snprintf(pktBuf, sizeof(pktBuf), "Received npkt (%d) frameSize (%u)"
			" to dump\n", npkt, frameSize);

		if (optionflag & LOGFILE_FLAG)
			printLocalTime(log_file[HOST_LOG_FILE].fp, "Debug Pkt Log Time : ", pktBuf);

		for (i = 0; i < npkt; i++) {
			bytes = snprintf(pktBuf, sizeof(pktBuf), "Debug Pkt Dump : ");
			hexDumpPacket(&pktBuf[bytes], wlanLog, frameSize);

			if (optionflag & CONSOLE_FLAG)
				android_printf("%s\n", pktBuf);

			if (optionflag & LOGFILE_FLAG) {
				cnss_write_buf_logs(strlen(pktBuf), pktBuf, HOST_LOG_FILE);
				cnss_write_buf_logs(strlen("\n") + 1, "\n", HOST_LOG_FILE);

			}
			wlanLog += frameSize;
		}
#endif
	}
}

static unsigned locate_next_seg(unsigned char *data,
				unsigned data_len,
				unsigned next_seg)
{
	while (next_seg < data_len) {
		if (data[next_seg++] == CONTROL_CHAR)
			break;
	}

	return next_seg;
}

static char *locate_next_str(char *data, unsigned data_len)
{
	/* To find the next string separated by '\0' */
	char *next_str;
	unsigned i = 0;

	next_str = data;
	while (*next_str != '\0' && i < data_len) {
		i++;
		next_str++;
	}

	/* re-locate to first char of string */
	while (*next_str == '\0' && i < data_len) {
		i++;
		next_str++;
	}

	/* Consider the next_str will contained at least '\0' */
	if (i >= (data_len - 1))
		return NULL;

	return next_str;
}

static int diag_hdlc_decode(struct diag_hdlc_decode_type *hdlc)
{
	uint8_t *src_ptr = NULL, *dest_ptr = NULL;
	unsigned int src_length = 0, dest_length = 0;

	unsigned int len = 0;
	unsigned int i;
	uint8_t src_byte;

	int pkt_bnd = HDLC_INCOMPLETE;
	int msg_start;

	if (hdlc && hdlc->src_ptr && hdlc->dest_ptr &&
	    (hdlc->src_size > hdlc->src_idx) &&
	    (hdlc->dest_size > hdlc->dest_idx)) {

		msg_start = (hdlc->src_idx == 0) ? 1 : 0;

		src_ptr = hdlc->src_ptr;
		src_ptr = &src_ptr[hdlc->src_idx];
		src_length = hdlc->src_size - hdlc->src_idx;

		dest_ptr = hdlc->dest_ptr;
		dest_ptr = &dest_ptr[hdlc->dest_idx];
		dest_length = hdlc->dest_size - hdlc->dest_idx;

		for (i = 0; i < src_length; i++) {

			src_byte = src_ptr[i];

			if (hdlc->escaping) {
				dest_ptr[len++] = src_byte ^ ESC_MASK;
				hdlc->escaping = 0;
			} else if (src_byte == ESC_CHAR) {
				if (i == (src_length - 1)) {
					hdlc->escaping = 1;
					i++;
					break;
				} else {
					dest_ptr[len++] = src_ptr[++i]
							  ^ ESC_MASK;
				}
			} else if (src_byte == CONTROL_CHAR) {
				if (msg_start && i == 0 && src_length > 1)
					continue;
				/* Byte 0x7E will be considered
					as end of packet */
				dest_ptr[len++] = src_byte;
				i++;
				pkt_bnd = HDLC_COMPLETE;
				break;
			} else {
				dest_ptr[len++] = src_byte;
			}

			if (len >= dest_length) {
				i++;
				break;
			}
		}

		hdlc->src_idx += i;
		hdlc->dest_idx += len;
	}

	return pkt_bnd;
}

int crc_check(uint8_t *buf, uint16_t len)
{
	uint16_t crc = CRC_16_L_SEED;
	uint8_t sent_crc[2] = {0, 0};

	/*
	 * The minimum length of a valid incoming packet is 4. 1 byte
	 * of data and 3 bytes for CRC
	 */
	if (!buf || len < 4) {
		printf("In %s, invalid packet or length, buf: 0x%p, len: %d",
				   __func__, buf, len);
		return -1;
	}

	/*
	 * Run CRC check for the original input. Skip the last 3 CRC
	 * bytes
	 */
	crc = crc_ccitt(crc, buf, len-3);
	crc ^= CRC_16_L_SEED;

	/* Check the computed CRC against the original CRC bytes. */
	sent_crc[0] = buf[len-3];
	sent_crc[1] = buf[len-2];
	if (crc != *((uint16_t *)sent_crc)) {
		printf("In %s, crc mismatch. expected: %x, sent %x.\n",
				__func__, crc, *((uint16_t *)sent_crc));
		return -1;
	}

	return 0;
}

static
void diag_hdlc_encode(struct diag_send_desc_type *src_desc,
		      struct diag_hdlc_dest_type *enc)
{
	uint8_t *dest;
	uint8_t *dest_last;
	const uint8_t *src;
	const uint8_t *src_last;
	uint16_t crc;
	unsigned char src_byte = 0;
	enum diag_send_state_enum_type state;
	unsigned int used = 0;

	if (src_desc && enc) {

		/* Copy parts to local variables. */
		src = src_desc->pkt;
		src_last = src_desc->last;
		state = src_desc->state;
		dest = enc->dest;
		dest_last = enc->dest_last;

		if (state == DIAG_STATE_START) {
			crc = CRC_16_L_SEED;
			state++;
		} else {
			/* Get a local copy of the CRC */
			crc = enc->crc;
		}

		/* dest or dest_last may be NULL to trigger a
		   state transition only */
		if (dest && dest_last) {
			/* This condition needs to include the possibility
			   of 2 dest bytes for an escaped byte */
			while (src <= src_last && dest <= dest_last) {

				src_byte = *src++;

				if ((src_byte == CONTROL_CHAR) ||
				    (src_byte == ESC_CHAR)) {

					/* If the escape character is not the
					   last byte */
					if (dest != dest_last) {
						crc = CRC_16_L_STEP(crc,
								    src_byte);

						*dest++ = ESC_CHAR;
						used++;

						*dest++ = src_byte
							  ^ ESC_MASK;
						used++;
					} else {

						src--;
						break;
					}

				} else {
					crc = CRC_16_L_STEP(crc, src_byte);
					*dest++ = src_byte;
					used++;
				}
			}

			if (src > src_last) {

				if (state == DIAG_STATE_BUSY) {
					if (src_desc->terminate) {
						crc = ~crc;
						state++;
					} else {
						/* Done with fragment */
						state = DIAG_STATE_COMPLETE;
					}
				}

				while (dest <= dest_last &&
				       state >= DIAG_STATE_CRC1 &&
				       state < DIAG_STATE_TERM) {
					/* Encode a byte of the CRC next */
					src_byte = crc & 0xFF;

					if ((src_byte == CONTROL_CHAR)
					    || (src_byte == ESC_CHAR)) {

						if (dest != dest_last) {

							*dest++ = ESC_CHAR;
							used++;
							*dest++ = src_byte ^
								  ESC_MASK;
							used++;

							crc >>= 8;
						} else {

							break;
						}
					} else {

						crc >>= 8;
						*dest++ = src_byte;
						used++;
					}

					state++;
				}

				if (state == DIAG_STATE_TERM) {
					if (dest_last >= dest) {
						*dest++ = CONTROL_CHAR;
						used++;
						state++;	/* Complete */
					}
				}
			}
		}
		/* Copy local variables back into the encode structure. */

		enc->dest = dest;
		enc->dest_last = dest_last;
		enc->crc = crc;
		src_desc->pkt = src;
		src_desc->last = src_last;
		src_desc->state = state;
	}

	return;
}

extern tSock fw_hdl;
int32_t fw_log_mask;

static int send_diag_cmd(int sock_fd, int32_t cmd, int len, uint8_t *buf)
{
	struct dbglog_slot *slot;
	struct sockaddr_nl dest_addr;
	struct nlmsghdr *nlh = NULL;
	struct msghdr msg;
	struct iovec iov;
	int32_t ret, slot_len = 0;

	slot_len =  sizeof(struct dbglog_slot) + len;
	char *slot_buf = NULL;
	slot_buf = malloc(slot_len);
	if (slot_buf == NULL) {
		fprintf(stderr, "Cannot allocate slot memory \n");
		return -1;
	}
	slot = (struct dbglog_slot *)slot_buf;
	memset(slot, 0 , sizeof(struct dbglog_slot));
	slot->diag_type = cmd;
	slot->length = len;
	memcpy(slot->payload, buf, len);

	memset(&dest_addr, 0, sizeof(dest_addr));
	dest_addr.nl_family = AF_NETLINK;
	dest_addr.nl_pid = 0; /* For Linux Kernel */
	dest_addr.nl_groups = 0; /* unicast */

	nlh = malloc(NLMSG_SPACE(slot_len));
	if (nlh == NULL) {
		fprintf(stderr, "Cannot allocate memory \n");
		free(slot_buf);
		return -1;
	}
	memset(nlh, 0, NLMSG_SPACE(slot_len));
	nlh->nlmsg_len = NLMSG_SPACE(slot_len);
	nlh->nlmsg_pid = getpid();
	nlh->nlmsg_type = WLAN_NL_CNSS_FW_MSG;
	nlh->nlmsg_flags = NLM_F_REQUEST;

	memcpy(NLMSG_DATA(nlh), slot_buf, slot_len);
	free(slot_buf);

	memset(&msg, 0, sizeof(msg));
	iov.iov_base = (void *)nlh;
	iov.iov_len = nlh->nlmsg_len;
	msg.msg_name = (void *)&dest_addr;
	msg.msg_namelen = sizeof(dest_addr);
	msg.msg_iov = &iov;
	msg.msg_iovlen = 1;

	ret  = sendmsg(sock_fd, &msg, 0);
	free(nlh);
	return ret;
}

static int diag_encode_send(void *buf, int len)
{
	int err = 0;
	int max_len = 0;
	struct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };
	struct diag_hdlc_dest_type enc = { NULL, NULL, 0 };
	unsigned char *hdlc_encode_buf;
	int hdlc_encode_buf_len;

	if (!buf)
		return -EINVAL;

	if (len <= 0) {
		fprintf(stderr, "diag: In %s, invalid len: %d", __func__, len);
		return -1;
	}

	hdlc_encode_buf = malloc(DIAG_MAX_HDLC_BUF_SIZE);
	if(!hdlc_encode_buf) {
		fprintf(stderr, "Cannot allocate hdlc_encode_buf memory \n");
		return -1;
	}

	/*
	 * The worst case length will be twice as the incoming packet length.
	 * Add 3 bytes for CRC bytes (2 bytes) and delimiter (1 byte)
	 */
	max_len = (2 * len) + 3;
	if (DIAG_MAX_HDLC_BUF_SIZE < max_len) {
		fprintf(stderr, "Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\n",
			max_len);
		free(hdlc_encode_buf);
		return -1;
	}

	/* Perform HDLC encoding on incoming data */
	send.state = DIAG_STATE_START;
	send.pkt = (void *)(buf);
	send.last = (void *)(buf + len - 1);
	send.terminate = 1;

	enc.dest = hdlc_encode_buf;
	enc.dest_last = (void *)(hdlc_encode_buf + max_len - 1);
	diag_hdlc_encode(&send, &enc);
	hdlc_encode_buf_len = (int)(enc.dest -
					(void *)hdlc_encode_buf);


	err = send_diag_cmd(fw_hdl.sock_fd, DIAG_TYPE_FW_MSG,
				hdlc_encode_buf_len, hdlc_encode_buf);
	if (err < 0)
		fprintf(stderr,"diag: send_diag_cmd failed, error code 0x%d\n",
			err);
	free(hdlc_encode_buf);
	return err;
}

/* set wlan diag msg mask cmd */
int diag_local_enable_debug_msg(void)
{
	struct diag_msg_build_mask_t *req = NULL;
	int req_len = 0;
	int ret = 0;
	int range = MSG_SSID_WLAN_LAST - MSG_SSID_WLAN + 1;
	int i = 0;
	uint32_t *mask_ptr = NULL;

	req = malloc(DIAG_MAX_REQ_SIZE);
	if (!req)
		return -EINVAL;

	req_len = sizeof(struct diag_msg_build_mask_t) + (range * sizeof (uint32_t));

	mask_ptr = (uint32_t *) (req + 1);

	req->cmd_code   = DIAG_CMD_MSG_CONFIG;
	req->sub_cmd    = DIAG_CMD_OP_SET_MSG_MASK;
	req->ssid_first = MSG_SSID_WLAN;
	req->ssid_last  = MSG_SSID_WLAN_LAST;
	req->padding    = 0;
	req->status     = 0;

	for (i = 0; i < range; i ++)
		mask_ptr[i] = fw_log_mask;

	/* start to send */
	ret = diag_encode_send(req, req_len);

	free(req);

	return ret;
}

/* set wlan diag event mask cmd */
int diag_local_enable_event(void)
{
#define EVENT_LAST_ID 0xB27

        struct diag_event_mask_config_t *req = NULL;
        int req_len = 0;
        int ret = 0;
        uint8_t *mask_ptr = NULL;
        uint16_t num_bytes = 0;
        int i = 0;
       
      	req = malloc(DIAG_MAX_REQ_SIZE);
	if (!req)
		return -EINVAL;
        
        mask_ptr = (uint8_t *) (req + 1);

        req->cmd_code = DIAG_CMD_SET_EVENT_MASK;
        req->status   = 0;
        req->padding  = 0;
        req->num_bits = EVENT_LAST_ID;
        num_bytes = (req->num_bits +7)/8;

        req_len = sizeof(struct diag_event_mask_config_t) + num_bytes;
       
        for(i = 0; i < num_bytes; i++)
            mask_ptr[i] = 0xFF;

       /* start to send */
	ret = diag_encode_send(req, req_len);

	free(req);

	return ret;       
}

/* send diag event toggle cmd */
int diag_local_event_toggle(uint8_t value)
{
	struct diag_event_toggle_config_t req;
	int req_len = 0;
	int ret = 0;
   
	req.cmd_code = DIAG_CMD_EVENT_TOGGLE;
	req.enable = value;
     
	req_len = sizeof(struct diag_event_toggle_config_t);
      
	ret = diag_encode_send(&req, req_len);
    
	return ret;
}

/* set wlan diag log mask cmd */
int diag_local_enable_log(void)
{
	struct diag_log_config_req_t *req = NULL;
	int req_len = 0;
	int ret = 0;
	uint8_t *mask_ptr = NULL;
	uint16_t num_bytes = 0;
	int i = 0;

	req = malloc(DIAG_MAX_REQ_SIZE);
	if (!req)
		return -EINVAL;

	mask_ptr = (uint8_t *) (req + 1);

	req->cmd_code = DIAG_CMD_LOG_CONFIG;
	req->padding[0] = 0;
	req->padding[1] = 0;
	req->padding[2] = 0;
	req->sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;
	req->equip_id = LOG_EQUIP_ID_1X;
	req->num_items = LOG_GET_ITEM_NUM(LOG_EQUIP_ID_1_LAST_CODE);
	num_bytes = (req->num_items/8) + 1;

        req_len = sizeof(struct diag_log_config_req_t) + num_bytes;

	/* temporarily enable all bits for equipment ID 0x1 */
	for(i = 0; i < num_bytes; i++)
	    mask_ptr[i] = 0xFF;

	/* start to send */
	ret = diag_encode_send(req, req_len);

	free(req);

	return ret;
}

/* set wlan diag log disable cmd */
int diag_local_disable_log(void)
{
	struct diag_log_config_req_t *req = NULL;
	int req_len = 0;
	int ret = 0;
	uint8_t *mask_ptr = NULL;
	uint16_t num_bytes = 0;
	int i = 0;

	req = malloc(DIAG_MAX_REQ_SIZE);
	if (!req)
		return -EINVAL;

	mask_ptr = (uint8_t *) (req + 1);

	req->cmd_code = DIAG_CMD_LOG_CONFIG;
	req->padding[0] = 0;
	req->padding[1] = 0;
	req->padding[2] = 0;
	req->sub_cmd = DIAG_CMD_OP_LOG_DISABLE;
	req->equip_id = LOG_EQUIP_ID_1X;
	req->num_items = LOG_GET_ITEM_NUM(LOG_EQUIP_ID_1_LAST_CODE);
	num_bytes = (req->num_items/8) + 1;

	req_len = sizeof(struct diag_log_config_req_t) + num_bytes;

	/* disable all bits for equipment ID 0x1 */
	for(i = 0; i < num_bytes; i++)
	    mask_ptr[i] = 0x0;

	/* start to send */
	ret = diag_encode_send(req, req_len);

	free(req);

	return ret;
}

extern struct s_hdlc_buf hdlc_buf;

static unsigned long long cnss_convert_fw_time(unsigned char ts_type, unsigned ts_lo, unsigned ts_hi)
{
       unsigned long long ts_counter_1 = 0;
       unsigned long long ts_counter_2 = 0;

       unsigned long long ts_value_1, ts_value_2;

       if(ts_type != 0)
         printf("%s: unknown timestamp type %d.\n", __func__, ts_type);
       
       ts_counter_1 = (((unsigned long long)ts_hi) << 16) + ((ts_lo & 0xFFFF0000) >> 16);
       ts_counter_2 = (ts_lo & 0x0000FFFF);

       ts_value_1 = ((ts_counter_1 * 1000) * 5) / 4;
       ts_value_2 = ((ts_counter_2 * 1000) / 9831 + 2) / 4;

       /* To do: looks the timestamp unit got here is not us, 
        * temporarily /2.5 to us.
        */
       return (ts_value_1 + ts_value_2)/ 5 * 2;  
}

#define WLAN_NL_MHI_ENABLED 0xFF

void process_cnss_fw_message(tAniCLDHdr *wnl, int32_t optionflag)
{
	unsigned char *data;
	unsigned len, radio_id;
	unsigned next_seg = 0;
	struct diag_hdlc_decode_type hdlc_decode;
        char tmbuf[TIME_DATA_SIZE];
	int ret;
        unsigned long long fw_time_us = 0;

	/* TODO: re-visit */
	UNUSED(optionflag);

        appendLocalTime(tmbuf);

	data = (unsigned char *)wnl;
	data += sizeof(*wnl);

	len = wnl->wmsg.length;


	/* try to store FW log to QXDM file */
	if(optionflag & LOGFILE_QXDM_FLAG)
		cnss_write_buf_logs(len, (char *)data, FW_QXDM_LOG_FILE);

	/* Init diag_db once */
	radio_id = wnl->wmsg.type;
	if (!gisdiag_init[radio_id]) {
		/* If cnss_diag is started if WIFI already ON,
		* then turn on event not received hence
		* before throwing out error initialize again
		*/
		diag_initialize(0, optionflag);
		if (!gisdiag_init[radio_id]) {
			printf("**ERROR** Diag not initialized\n");
			return;
		}
	}

	/* Check if MHI enabled notifier firstly */
	if (len == sizeof(unsigned char) && (*data == WLAN_NL_MHI_ENABLED)) {
		debug_printf("%s: Get the MHI_ENABLED notifier from DIAG modules\n",
			__func__);
		diag_local_enable_debug_msg();
		/* only enable diag msg temporarily to avoid too much log,
		 * to enable diag event and log, type in parameter
		 * "cnss_diag_lite -e 1" when start application.
		 */

		/* diag_local_event_toggle(1);
		   diag_local_enable_event();
		   diag_local_enable_log(); */

		return;
	}

	/* parse each segment */
	while (next_seg < len) {

		/* Prepare hdlc params */
		hdlc_decode.dest_ptr = hdlc_buf.buf;
		hdlc_decode.dest_size = MAX_HDLC_BUF_SIZE;
		hdlc_decode.src_ptr = data;
		hdlc_decode.src_size = len;
		hdlc_decode.src_idx = next_seg;
		hdlc_decode.dest_idx = hdlc_buf.used_len/*0*/;
		hdlc_decode.escaping = 0; /* re-visit */

		/* decode hdlc */
		ret = diag_hdlc_decode(&hdlc_decode);

		/*
		 * driver->hdlc_buf is of size DIAG_MAX_HDLC_BUF_SIZE. But the decoded
		 * packet should be within DIAG_MAX_REQ_SIZE.
		 */
		if (hdlc_buf.used_len + hdlc_decode.dest_idx <= MAX_REQ_SIZE) {
			hdlc_buf.used_len = hdlc_decode.dest_idx;
		} else {
			printf("In %s, Dropping packet. pkt_size: %d, max: %d\n",
				   __func__,
				   hdlc_buf.used_len + hdlc_decode.dest_idx,
				   MAX_REQ_SIZE);
			hdlc_buf.used_len = 0;
			return;
		}

		/*  CRC */
		if (ret == HDLC_COMPLETE) {
			ret = crc_check(hdlc_buf.buf, hdlc_buf.used_len);
			if (ret) {
				/* CRC check failed. */
				printf("In %s, bad CRC. Dropping packet\n",
						   __func__);
				goto next;
			}
			hdlc_buf.used_len -= HDLC_FOOTER_LEN;

			if (hdlc_buf.used_len < 1) {
				printf("In %s, message is too short, len: %d, dest len: %d\n",
					   __func__, hdlc_buf.used_len,
					   hdlc_decode.dest_idx);
				goto next;
			}
		} else {
			/* Check if all src buffer processed, while not complete */
			if (hdlc_decode.src_idx == hdlc_decode.src_size)
				return;

			goto next;
		}

		/* Let's test the decoded string here */
		switch (hdlc_buf.buf[0]) {
		case DIAG_EXT_MSG_F:
		{
			msg_ext_type *msg_ext = (msg_ext_type *)hdlc_buf.buf;
			char *msg_str = (char *)msg_ext->args +
				msg_ext->hdr.num_args * sizeof(unsigned);
			char buf[BUF_SIZ], *start, *next_str;
			uint32_t msg_len;

                        fw_time_us = cnss_convert_fw_time(msg_ext->hdr.ts_type, 
                                                          msg_ext->hdr.ts_lo, msg_ext->hdr.ts_hi);
			next_str = locate_next_str(msg_str, BUF_SIZ);
			if (!next_str)
				next_str = "Unknown";

			if (msg_ext->hdr.num_args != 0) {
				memset(buf, 0, BUF_SIZ);
				msg_len = msg_ext->hdr.num_args *
						sizeof(msg_ext->args[0]);
				start = buf;

				pack_printf(dbg_write_char,
					    &start,
					    start + sizeof(buf),
					    msg_str,
					    msg_str,
					    (uint8_t*)&msg_ext->args[0],
					    msg_len);

				printf("[%s][%llu.%llu][id/mask %d/%d][%-16.16s %4d]: %s\n",
                                        tmbuf, fw_time_us/1000000,fw_time_us%1000000,
					msg_ext->desc.ss_id,
					msg_ext->desc.ss_mask,
					next_str, msg_ext->desc.line, buf);
			} else {
				printf("[%s][%llu.%llu][id/mask %d/%d][%-16.16s %4d]: %s\n",
                                        tmbuf, fw_time_us/1000000,fw_time_us%1000000,
					msg_ext->desc.ss_id,
					msg_ext->desc.ss_mask,
					next_str, msg_ext->desc.line, msg_str);
			}
			break;
		}

		case DIAG_QSR_EXT_MSG_TERSE_F:
		{
			msg_qsr_type *msg_qsr = (msg_qsr_type *)hdlc_buf.buf;
			static diag_entry *p_entry;
			char buf[BUF_SIZ], *start;

                        fw_time_us = cnss_convert_fw_time(msg_qsr->hdr.ts_type, 
                                                          msg_qsr->hdr.ts_lo, msg_qsr->hdr.ts_hi);
			p_entry = diag_find_by_id(msg_qsr->msg_hash, radio_id);
			if (!p_entry) {
				printf("Not find ID %u\n", msg_qsr->msg_hash);
				break;
			}

			memset(buf, 0, BUF_SIZ);
			p_entry->msg_len = msg_qsr->hdr.num_args *
						sizeof(msg_qsr->args[0]);
			p_entry->msg = (char *)&msg_qsr->args[0];
			start = buf;

			pack_printf(dbg_write_char,
				    &start,
				    start + sizeof(buf),
				    p_entry->format,
				    p_entry->pack,
				    (uint8_t*)p_entry->msg,
				    p_entry->msg_len);
			printf("[%s][%llu.%llu][id/mask %d/%d][%-32.32s %4d]: %s\n",
                                tmbuf, fw_time_us/1000000,fw_time_us%1000000,
				msg_qsr->desc.ss_id, msg_qsr->desc.ss_mask,
				p_entry->pack, msg_qsr->desc.line,  buf);

			if (optionflag & LOGFILE_FLAG) {
				char pfilebuf[MAX_SIZE];
				int bytes_copied = 0;

				bytes_copied = snprintf(pfilebuf, MAX_SIZE,
							"[%s][%llu.%llu][id/mask %d/%d][%-16.16s %4d]: %s\n",
							tmbuf, fw_time_us/1000000,fw_time_us%1000000,
							msg_qsr->desc.ss_id, msg_qsr->desc.ss_mask,
							p_entry->pack, msg_qsr->desc.line,  buf);
				cnss_write_buf_logs(bytes_copied, pfilebuf, FW_LOG_FILE);
			}

			break;
		}

                case DIAG_EVENT_REPORT_F:
                {
                      debug_printf("%s: FW diag event!!.\n", __func__);
                      break;
                }

                case DIAG_LOG_F:
                {     debug_printf("%s: FW diag log!!.\n", __func__);
                      break;
                }

		default:
			debug_printf("Unsupport type %d: %2X-%2X-%2X-%2X-%2X\n",
				hdlc_buf.buf[0],
				hdlc_buf.buf[1], hdlc_buf.buf[2],
				hdlc_buf.buf[3], hdlc_buf.buf[4],
				hdlc_buf.buf[5]);
		}

next:
		hdlc_buf.used_len = 0;
		/* locate to next msg segment */
		next_seg = locate_next_seg(data, len, next_seg);
	}
}

#if DIAG_KEEP_ORIG
void process_pronto_firmware_logs(tAniNlHdr *wnl, int32_t optionflag)
{
	char *wlanLog = (char *)&wnl->wmsg.length + sizeof(wnl->wmsg.length);

	if (!wlanLog)
		return;
	if (optionflag & CONSOLE_FLAG)
		android_printf("%s\n", wlanLog);
	if (optionflag & LOGFILE_FLAG)
		cnss_write_buf_logs(wnl->wmsg.length, wlanLog, FW_LOG_FILE);
	if (optionflag & LOG_BUFF_FLAG && optionflag & DECODED_LOG_FLAG)
		cnss_logs_to_buffer(wnl->wmsg.length, wlanLog, BUFFER_FW_FILE);
}

void process_cnss_host_diag_events_log(char *pData, int32_t optionflag)
{
	uint32_t diag_type = 0;

	if (optionflag & QXDM_FLAG) {
		if (pData) {
			diag_type = *(uint32_t*) pData;
			pData += sizeof(uint32_t);
		}
		if (diag_type == DIAG_TYPE_LOGS) {
			log_hdr_type *pHdr = (log_hdr_type*)pData;
			if (log_status(pHdr->code))
				{
				log_set_timestamp(pHdr);
				log_submit(pHdr);
			}
		} else if (diag_type == DIAG_TYPE_EVENTS) {
			uint16_t event_id;
			uint16_t length;
			event_id = *(uint16_t*)pData;
			pData += sizeof(uint16_t);
			length = *(uint16_t*)pData;
			pData += sizeof(uint16_t);
			event_report_payload(event_id,length,pData);
		}
	}
}

#endif

